---
layout:     post
title:      最大数组问题
subtitle:   
date:       2018-02-12
author:     BY
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - 算法
    - 位运算
---

基本操作：

```
| : 逻辑或 一个数与1或该位一定是1. 用来置1.  

& ：逻辑与 一个数与1与，用来查看该位是否是1.

^ : 异或：用来判断有多少个不同的数据位。

```

移位操作：

**重点注意**   
>数的正负

```
>> 逻辑右移：正数向右移动。高位补0.
             负数向右移动。高位补1.（重点）

<< 逻辑左移：负数高位不伴随移动。

```

常用技能：

1.判断一个该数的该位是否为1？

(n >> m & 1) == 1

2.判断二进制中1的位数？

```
while( n != 0){
    if(n & 1 == 1){
        count++;
    }
    n = n >> 1;
}

```
分析：可能存在死循环。
当n为负数，右移后高位补1.最终0xffffffff.

```
int flag = 1;
while(flag != 0){
    if(n & flag == 1){
        count++;
    }
    flag = flag << 1;
}

```

分析：要遍历所有位数，与1的个数无关，效率低。

如何只计算1存在的个数？



```
10的二进制： 1001 1的个数为2
如果用方法2要flag左移32次，才能求出个数。

分析：1001 - 1 = 1000
1001 & 1000 = 1000

8的二进制：1000 1的个数为1.

分析： 1000 - 1 = 0111
1000 & 0111 = 0000

上述减1操作其实在去掉左边最近的1.
与操作获得新的值。

可以发现如果 (n - 1) & n 可以消掉左边的1.最终数据为0.
执行的次数和1的个数有关。
一个高效的算法诞生了。

```

```
int count = 0;
while(n != 0){
    n = (n -1) & n;
    count++;
}

```

相关问题：

一条语句表达一个数是不是2的n次方。

(n-1) & n == 0

两个整数m,n。m 改变多少次可以得到n.每次改变1位。

1.先异或得到不同位的数。
2.在进行计算1的个数。